<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://githaojiejie.github.io/</id>
    <title>我也有一颗糖</title>
    <updated>2021-08-19T11:58:14.235Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://githaojiejie.github.io/"/>
    <link rel="self" href="https://githaojiejie.github.io/atom.xml"/>
    <subtitle>生命中有三件必经之事, 荣誉, 死亡, 还有宿醉</subtitle>
    <logo>https://githaojiejie.github.io/images/avatar.png</logo>
    <icon>https://githaojiejie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 我也有一颗糖</rights>
    <entry>
        <title type="html"><![CDATA[更好的协程]]></title>
        <id>https://githaojiejie.github.io/post/geng-hao-de-xie-cheng/</id>
        <link href="https://githaojiejie.github.io/post/geng-hao-de-xie-cheng/">
        </link>
        <updated>2021-08-19T11:57:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="更好的协程">更好的协程</h1>
<p>上文讲了一串回调就是协程，显然这样写代码，增加逻辑，插入逻辑非常容易出错。我们需要利用异步语法把这个异步回调的形式改成同步的形式，幸好C#已经帮我们设计好了，看代码</p>
<pre><code class="language-csharp">    // example2_2
    class Program
    {
        private static int loopCount = 0;
        
        static void Main(string[] args)
        {
            OneThreadSynchronizationContext _ = OneThreadSynchronizationContext.Instance;

            Console.WriteLine($&quot;主线程: {Thread.CurrentThread.ManagedThreadId}&quot;);
            
            Crontine();
            
            while (true)
            {
                OneThreadSynchronizationContext.Instance.Update();
                
                Thread.Sleep(1);
                
                ++loopCount;
                if (loopCount % 10000 == 0)
                {
                    Console.WriteLine($&quot;loop count: {loopCount}&quot;);
                }
            }
        }

        private static async void Crontine()
        {
            await WaitTimeAsync(5000);
            Console.WriteLine($&quot;当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
            await WaitTimeAsync(4000);
            Console.WriteLine($&quot;当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
            await WaitTimeAsync(3000);
            Console.WriteLine($&quot;当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
        }
        
        private static Task WaitTimeAsync(int waitTime)
        {
            TaskCompletionSource&lt;bool&gt; tcs = new TaskCompletionSource&lt;bool&gt;();
            Thread thread = new Thread(()=&gt;WaitTime(waitTime, tcs));
            thread.Start();
            return tcs.Task;
        }
        
        /// &lt;summary&gt;
        /// 在另外的线程等待
        /// &lt;/summary&gt;
        private static void WaitTime(int waitTime, TaskCompletionSource&lt;bool&gt; tcs)
        {
            Thread.Sleep(waitTime);
            
            // 将tcs扔回主线程执行
            OneThreadSynchronizationContext.Instance.Post(o=&gt;tcs.SetResult(true), null);
        }
    }
</code></pre>
<p>在这段代码里面，WaitTimeAsync方法中，我们利用了TaskCompletionSource类替代了之前传入的Action参数，WaitTimeAsync方法返回了一个Task类型的结果。WaitTime中我们把action()替换成了tcs.SetResult(true),WaitTimeAsync方法前使用await关键字，这样可以将一连串的回调改成同步的形式。这样一来代码显得十分简洁，开发起来也方便多了。</p>
<p>这里还有个技巧，我们发现WaitTime中需要将tcs.SetResult扔回到主线程执行，微软给我们提供了一种简单的方法，参考example2_2_2，在主线程设置好同步上下文，</p>
<pre><code class="language-csharp">// example2_2_2
SynchronizationContext.SetSynchronizationContext(OneThreadSynchronizationContext.Instance);
</code></pre>
<p>在WaitTime中直接调用tcs.SetResult(true)就行了，回调会自动扔到同步上下文中，而同步上下文我们可以在主线程中取出回调执行，这样自动能够完成回到主线程的操作</p>
<pre><code class="language-csharp">        private static void WaitTime(int waitTime, TaskCompletionSource&lt;bool&gt; tcs)
        {
            Thread.Sleep(waitTime);

            tcs.SetResult(true);
        }
</code></pre>
<p>如果不设置同步上下文，你会发现打印出来当前线程就不是主线程了，这也是很多第三方库跟.net core内置库的用法，默认不回调到主线程，所以我们使用的时候需要设置下同步上下文。其实这个设计本人觉得没有必要，交由库的开发者去实现更好，尤其是在游戏开发中，逻辑全部是单线程的，回调每次都走一遍同步上下文就显得多余了，所以ET框架提供了不使用同步上下文的实现ETTask，代码更加简洁更加高效，这个后面会讲到。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[协程]]></title>
        <id>https://githaojiejie.github.io/post/xie-cheng/</id>
        <link href="https://githaojiejie.github.io/post/xie-cheng/">
        </link>
        <updated>2021-08-19T11:56:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是协程">什么是协程</h1>
<p>说到协程，我们先了解什么是异步，异步简单说来就是，我要发起一个调用，但是这个被调用方（可能是其它线程，也可能是IO）出结果需要一段时间，我不想让这个调用阻塞住调用方的整个线程，因此传给被调用方一个回调函数，被调用方运行完成后回调这个回调函数就能通知调用方继续往下执行。举个例子:<br>
下面的代码，主线程一直循环，每循环一次sleep 1毫秒，计数加一，每10000次打印一次。</p>
<pre><code class="language-csharp">        private static void Main()
        {
            int loopCount = 0;
            while (true)
            {
                int temp = watcherValue;
                
                Thread.Sleep(1);
                
                ++loopCount;
                if (loopCount % 10000 == 0)
                {
                    Console.WriteLine($&quot;loop count: {loopCount}&quot;);
                }
            }
        }
</code></pre>
<p>这时我需要加个功能，在程序一开始，我希望在5秒钟之后打印出loopCount的值。看到5秒后我们可以想到Sleep方法，它会阻塞线程一定时间然后继续执行。我们显然不能在主线程中Sleep，因为会破坏掉每10000次计数打印一次的逻辑。</p>
<pre><code class="language-csharp">    // example2_1
    class Program
    {
        private static int loopCount = 0;

        private static void Main()
        {
            OneThreadSynchronizationContext _ = OneThreadSynchronizationContext.Instance;
            
            WaitTimeAsync(5000, WaitTimeFinishCallback);
            
            while (true)
            {
                OneThreadSynchronizationContext.Instance.Update();
                
                Thread.Sleep(1);
                
                ++loopCount;
                if (loopCount % 10000 == 0)
                {
                    Console.WriteLine($&quot;loop count: {loopCount}&quot;);
                }
            }
        }

        private static void WaitTimeAsync(int waitTime, Action action)
        {
            Thread thread = new Thread(()=&gt;WaitTime(waitTime, action));
            thread.Start();
        }
        
        private static void WaitTimeFinishCallback()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
        }

        /// &lt;summary&gt;
        /// 在另外的线程等待
        /// &lt;/summary&gt;
        private static void WaitTime(int waitTime, Action action)
        {
            Thread.Sleep(waitTime);
            
            // 将action扔回主线程执行
            OneThreadSynchronizationContext.Instance.Post((o)=&gt;action(), null);
        }
    }
</code></pre>
<p>我们在这里设计了一个WaitTimeAsync方法，WaitTimeAsync其实就是一个典型的异步方法，它从主线程发起调用，传入了一个WaitTimeFinishCallback回调方法做参数，开启了一个线程，线程Sleep一定时间后，将传过来的回调扔回到主线程执行。OneThreadSynchronizationContext是一个跨线程队列，任何线程可以往里面扔委托，OneThreadSynchronizationContext的Update方法在主线程中调用，会将这些委托取出来放到主线程执行。为什么回调方法需要扔回到主线程执行呢？因为回调方法中读取了loopCount，loopCount在主线程中也有读写，所以要么加锁，要么永远保证只在主线程中读写。加锁是个不好的做法，代码中到处是锁会导致阅读跟维护困难，很容易产生多线程bug。这种将逻辑打包成委托然后扔回另外一个线程是多线程开发中常用的技巧。</p>
<p>我们可能又有个新需求，WaitTimeFinishCallback执行完成之后，再想等3秒，再打印一下loopCount。</p>
<pre><code class="language-csharp">        private static void WaitTimeAsync(int waitTime, Action action)
        {
            Thread thread = new Thread(()=&gt;WaitTime(waitTime, action));
            thread.Start();
        }
        private static void WaitTimeFinishCallback()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
            WaitTimeAsync(3000, WaitTimeFinishCallback2);
        }
        
        private static void WaitTimeFinishCallback2()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
        }
</code></pre>
<p>我们这时还可能改需求，需要在程序启动5秒后，接下来4秒，再接下来3秒，打印loopCount，也就是上面的逻辑中间再插入一个3秒等待。</p>
<pre><code class="language-csharp">        private static void WaitTimeAsync(int waitTime, Action action)
        {
            Thread thread = new Thread(()=&gt;WaitTime(waitTime, action));
            thread.Start();
        }
        
        private static void WaitTimeFinishCallback()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
            WaitTimeAsync(4000, WaitTimeFinishCallback3);
        }
        
        private static void WaitTimeFinishCallback3()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
            WaitTimeAsync(3000, WaitTimeFinishCallback2);
        }
        
        private static void WaitTimeFinishCallback2()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
        }
</code></pre>
<p>这样中间插入一段代码，显得非常麻烦。这里可以回答什么是协程了，其实这一串串回调就是协程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ILRuntime]]></title>
        <id>https://githaojiejie.github.io/post/ilruntime/</id>
        <link href="https://githaojiejie.github.io/post/ilruntime/">
        </link>
        <updated>2021-08-19T11:25:49.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>基础知识<br>
官方文档：https://ourpalm.github.io/ILRuntime/<br>
离线帮助文档目录：ILRuntime\docs\source\src\v1\guide<br>
官方Unity3D热更例子工程：https://github.com/Ourpalm/ILRuntimeU3D/</p>
</li>
<li>
<p>ILRuntime肯定可以做到IOS的热更。</p>
</li>
<li>
<p>本文中的名词解释：</p>
<p>域 : 应用程序的上下文，可以理解为使用热更之后，在游戏中存在两个域，一个是游戏主程序，另一     个是热更域。</p>
<p>CLR: Unity脚本(C#)的公共运行库，公共运行环境</p>
<p>Assembly-CSharp.dll: Unity脚本(C#)的编译成的dll，非特殊目录下的脚本都放在这个dll      下。安卓下可通过反射获取方法和变量。</p>
<p>hotFix.dll： 指热更工程生成的dll，和Unity主工程是两个不同的dll。</p>
</li>
<li>
<p>调试插件<br>
http://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不期而遇的夏天 - 陈奕迅]]></title>
        <id>https://githaojiejie.github.io/post/bu-qi-er-yu-de-xia-tian-chen-yi-xun/</id>
        <link href="https://githaojiejie.github.io/post/bu-qi-er-yu-de-xia-tian-chen-yi-xun/">
        </link>
        <updated>2021-08-19T10:08:51.000Z</updated>
        <content type="html"><![CDATA[<iframe class="music" frameborder="no" src="//music.163.com/outchain/player?type=2&id=1869983814&auto=1&height=90"></iframe>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛逼的网站]]></title>
        <id>https://githaojiejie.github.io/post/niu-bi-de-wang-zhan/</id>
        <link href="https://githaojiejie.github.io/post/niu-bi-de-wang-zhan/">
        </link>
        <updated>2021-08-19T07:27:46.000Z</updated>
        <content type="html"><![CDATA[<p>AI分享网站 : http://www.aisharing.com/sitemap<br>
卡通资源网 : https://www.spriters-resource.com/<br>
UGUI : https://bitbucket.org/UnityUIExtensions/unity-ui-extensions/src/release/<br>
攀爬系统 : https://bitbucket.org/catlikecodingunitytutorials/movement-08-climbing/commits/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Readme]]></title>
        <id>https://githaojiejie.github.io/post/Readme/</id>
        <link href="https://githaojiejie.github.io/post/Readme/">
        </link>
        <updated>2021-08-19T05:33:10.000Z</updated>
        <summary type="html"><![CDATA[<iframe class="music" frameborder="no" src="//music.163.com/outchain/player?type=2&id=1808268483&auto=1&height=90"></iframe>
<p>作为技术博客记录成长的过程</p>
]]></summary>
        <content type="html"><![CDATA[<iframe class="music" frameborder="no" src="//music.163.com/outchain/player?type=2&id=1808268483&auto=1&height=90"></iframe>
<p>作为技术博客记录成长的过程</p>
<!-- more -->
]]></content>
    </entry>
</feed>