<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://githaojiejie.github.io/</id>
    <title>我也有一颗糖</title>
    <updated>2021-08-19T11:56:51.043Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://githaojiejie.github.io/"/>
    <link rel="self" href="https://githaojiejie.github.io/atom.xml"/>
    <subtitle>生命中有三件必经之事, 荣誉, 死亡, 还有宿醉</subtitle>
    <logo>https://githaojiejie.github.io/images/avatar.png</logo>
    <icon>https://githaojiejie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 我也有一颗糖</rights>
    <entry>
        <title type="html"><![CDATA[协程]]></title>
        <id>https://githaojiejie.github.io/post/xie-cheng/</id>
        <link href="https://githaojiejie.github.io/post/xie-cheng/">
        </link>
        <updated>2021-08-19T11:56:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是协程">什么是协程</h1>
<p>说到协程，我们先了解什么是异步，异步简单说来就是，我要发起一个调用，但是这个被调用方（可能是其它线程，也可能是IO）出结果需要一段时间，我不想让这个调用阻塞住调用方的整个线程，因此传给被调用方一个回调函数，被调用方运行完成后回调这个回调函数就能通知调用方继续往下执行。举个例子:<br>
下面的代码，主线程一直循环，每循环一次sleep 1毫秒，计数加一，每10000次打印一次。</p>
<pre><code class="language-csharp">        private static void Main()
        {
            int loopCount = 0;
            while (true)
            {
                int temp = watcherValue;
                
                Thread.Sleep(1);
                
                ++loopCount;
                if (loopCount % 10000 == 0)
                {
                    Console.WriteLine($&quot;loop count: {loopCount}&quot;);
                }
            }
        }
</code></pre>
<p>这时我需要加个功能，在程序一开始，我希望在5秒钟之后打印出loopCount的值。看到5秒后我们可以想到Sleep方法，它会阻塞线程一定时间然后继续执行。我们显然不能在主线程中Sleep，因为会破坏掉每10000次计数打印一次的逻辑。</p>
<pre><code class="language-csharp">    // example2_1
    class Program
    {
        private static int loopCount = 0;

        private static void Main()
        {
            OneThreadSynchronizationContext _ = OneThreadSynchronizationContext.Instance;
            
            WaitTimeAsync(5000, WaitTimeFinishCallback);
            
            while (true)
            {
                OneThreadSynchronizationContext.Instance.Update();
                
                Thread.Sleep(1);
                
                ++loopCount;
                if (loopCount % 10000 == 0)
                {
                    Console.WriteLine($&quot;loop count: {loopCount}&quot;);
                }
            }
        }

        private static void WaitTimeAsync(int waitTime, Action action)
        {
            Thread thread = new Thread(()=&gt;WaitTime(waitTime, action));
            thread.Start();
        }
        
        private static void WaitTimeFinishCallback()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
        }

        /// &lt;summary&gt;
        /// 在另外的线程等待
        /// &lt;/summary&gt;
        private static void WaitTime(int waitTime, Action action)
        {
            Thread.Sleep(waitTime);
            
            // 将action扔回主线程执行
            OneThreadSynchronizationContext.Instance.Post((o)=&gt;action(), null);
        }
    }
</code></pre>
<p>我们在这里设计了一个WaitTimeAsync方法，WaitTimeAsync其实就是一个典型的异步方法，它从主线程发起调用，传入了一个WaitTimeFinishCallback回调方法做参数，开启了一个线程，线程Sleep一定时间后，将传过来的回调扔回到主线程执行。OneThreadSynchronizationContext是一个跨线程队列，任何线程可以往里面扔委托，OneThreadSynchronizationContext的Update方法在主线程中调用，会将这些委托取出来放到主线程执行。为什么回调方法需要扔回到主线程执行呢？因为回调方法中读取了loopCount，loopCount在主线程中也有读写，所以要么加锁，要么永远保证只在主线程中读写。加锁是个不好的做法，代码中到处是锁会导致阅读跟维护困难，很容易产生多线程bug。这种将逻辑打包成委托然后扔回另外一个线程是多线程开发中常用的技巧。</p>
<p>我们可能又有个新需求，WaitTimeFinishCallback执行完成之后，再想等3秒，再打印一下loopCount。</p>
<pre><code class="language-csharp">        private static void WaitTimeAsync(int waitTime, Action action)
        {
            Thread thread = new Thread(()=&gt;WaitTime(waitTime, action));
            thread.Start();
        }
        private static void WaitTimeFinishCallback()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
            WaitTimeAsync(3000, WaitTimeFinishCallback2);
        }
        
        private static void WaitTimeFinishCallback2()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
        }
</code></pre>
<p>我们这时还可能改需求，需要在程序启动5秒后，接下来4秒，再接下来3秒，打印loopCount，也就是上面的逻辑中间再插入一个3秒等待。</p>
<pre><code class="language-csharp">        private static void WaitTimeAsync(int waitTime, Action action)
        {
            Thread thread = new Thread(()=&gt;WaitTime(waitTime, action));
            thread.Start();
        }
        
        private static void WaitTimeFinishCallback()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
            WaitTimeAsync(4000, WaitTimeFinishCallback3);
        }
        
        private static void WaitTimeFinishCallback3()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
            WaitTimeAsync(3000, WaitTimeFinishCallback2);
        }
        
        private static void WaitTimeFinishCallback2()
        {
            Console.WriteLine($&quot;WaitTimeAsync finsih loopCount的值是: {loopCount}&quot;);
        }
</code></pre>
<p>这样中间插入一段代码，显得非常麻烦。这里可以回答什么是协程了，其实这一串串回调就是协程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ILRuntime]]></title>
        <id>https://githaojiejie.github.io/post/ilruntime/</id>
        <link href="https://githaojiejie.github.io/post/ilruntime/">
        </link>
        <updated>2021-08-19T11:25:49.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>基础知识<br>
官方文档：https://ourpalm.github.io/ILRuntime/<br>
离线帮助文档目录：ILRuntime\docs\source\src\v1\guide<br>
官方Unity3D热更例子工程：https://github.com/Ourpalm/ILRuntimeU3D/</p>
</li>
<li>
<p>ILRuntime肯定可以做到IOS的热更。</p>
</li>
<li>
<p>本文中的名词解释：</p>
<p>域 : 应用程序的上下文，可以理解为使用热更之后，在游戏中存在两个域，一个是游戏主程序，另一     个是热更域。</p>
<p>CLR: Unity脚本(C#)的公共运行库，公共运行环境</p>
<p>Assembly-CSharp.dll: Unity脚本(C#)的编译成的dll，非特殊目录下的脚本都放在这个dll      下。安卓下可通过反射获取方法和变量。</p>
<p>hotFix.dll： 指热更工程生成的dll，和Unity主工程是两个不同的dll。</p>
</li>
<li>
<p>调试插件<br>
http://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不期而遇的夏天 - 陈奕迅]]></title>
        <id>https://githaojiejie.github.io/post/bu-qi-er-yu-de-xia-tian-chen-yi-xun/</id>
        <link href="https://githaojiejie.github.io/post/bu-qi-er-yu-de-xia-tian-chen-yi-xun/">
        </link>
        <updated>2021-08-19T10:08:51.000Z</updated>
        <content type="html"><![CDATA[<iframe class="music" frameborder="no" src="//music.163.com/outchain/player?type=2&id=1869983814&auto=1&height=90"></iframe>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛逼的网站]]></title>
        <id>https://githaojiejie.github.io/post/niu-bi-de-wang-zhan/</id>
        <link href="https://githaojiejie.github.io/post/niu-bi-de-wang-zhan/">
        </link>
        <updated>2021-08-19T07:27:46.000Z</updated>
        <content type="html"><![CDATA[<p>AI分享网站 : http://www.aisharing.com/sitemap<br>
卡通资源网 : https://www.spriters-resource.com/<br>
UGUI : https://bitbucket.org/UnityUIExtensions/unity-ui-extensions/src/release/<br>
攀爬系统 : https://bitbucket.org/catlikecodingunitytutorials/movement-08-climbing/commits/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Readme]]></title>
        <id>https://githaojiejie.github.io/post/Readme/</id>
        <link href="https://githaojiejie.github.io/post/Readme/">
        </link>
        <updated>2021-08-19T05:33:10.000Z</updated>
        <summary type="html"><![CDATA[<iframe class="music" frameborder="no" src="//music.163.com/outchain/player?type=2&id=1808268483&auto=1&height=90"></iframe>
<p>作为技术博客记录成长的过程</p>
]]></summary>
        <content type="html"><![CDATA[<iframe class="music" frameborder="no" src="//music.163.com/outchain/player?type=2&id=1808268483&auto=1&height=90"></iframe>
<p>作为技术博客记录成长的过程</p>
<!-- more -->
]]></content>
    </entry>
</feed>